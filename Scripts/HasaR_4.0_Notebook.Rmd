---
title: "HasaR - Hagelschadenschaetzung anhand Radardaten"
author: "Mirco Heidemann"
date: "May 2022"
output:
  pdf_document: default
---

Statistische Modellierung von Hagelschaeden anhand Radardate fuer Ereignisse mit ueber 1'000 Schadenmeldungen.

1. Gegitterte GemDat Daten laden
- Anzahl Gebaeude und Versicherungssumme pro 1km^2 Gitter des Meteoschweiz Radars
- Fuer eine Aktuallisierung des GVZ Portfolios, erst das R-Skript "Aggregate.GemDat.MeteoSwiss.Grid.R" ausfuehren
2. Schaetzung der Schadensumme mit dem statistischen Modell
- Eine **logistische Regression** schaetzt die Wahrscheinlichkeit fuer einen Schadenseintritt, die erwartete Schadenssumme pro Gitterzellen wird mit einem **GLM mit Gamma Verteilung** modelliert
- Es werden nur Gitterzellen mit mindestens einem Gebaeude und einer POH von mindestens 80% betrachtet
3. PDF - Karten erstellen
- MESHS (Maximale Korngroesse am Boden) der MeteoSchweiz
- POH (Hagelwahrscheinlichkeit) der MeteoSchweiz
- Geschaetzte Schadensumme pro Gitter und Gemeinde
- (Geschaetzte Anzahl Schaeden pro Gemeinde)
- Leaflet - Karte mit MESHS und Schadensumme pro Gitter
4. Schaetzung der Schadensumme nach der INTERPOL Methode
- Empirischen Betroffenheitsgraden je Baujahrskategorie und einem Durchschnittsschaden von CHF 6'000.  

Version: HasaR 4.0
---

```{r}
## HIER DAS DATUM DES RADARBILDS ANGEBEN
eventDat <- '01.08.2017'
```

**Funktionen und Packages laden**
RMarkdown files are a special case, as they work slightly differently to .R files in terms of file paths, i.e. they behave like mini projects of their own, where the default working directory is where the Rmd file is saved. To save RMarkdown files in a basic folder structure set up, it’s recommended to use the [here package](https://github.com/jennybc/here_here) and its workflow.
```{r eval = FALSE, warning = FALSE}
## Funktionen und Packages laden
library(tidyverse)
library(rgdal)
library(here)
library(raster)
library(leaflet)
library(fields)
library(RColorBrewer)
library(htmlwidgets)

pth_data <- here("Data/")
pth_tbl <- here("Data/tables/")
pth_func <- here("Data/rfunctions/")
pth_pres <- here("Output/")
pth_tif <- here("Data/radarTiffs/")
pth_rdata <- here("Data/rdata/")
pth_shp <- here("Data/shapes/")

## Skript zum Rotieren bzw. Spiegeln vom Radar-Bild laden
source(paste0(pth_func, 'Rotate.R'))
## Funktion um neue Faktor-Levels predict-Datensatz auf NA zu setzen
source(paste0(pth_func, 'RemoveMissingLevels.R'))
```

Daten laden und aufbereiten
```{r eval = FALSE, warning = FALSE}
dat <- as.Date(eventDat, "%d.%m.%Y", tz = "Europe/Berlin")
poh_name <- paste0('poh.', format(dat, "%Y%m%d"),'.tif')
meshs_name <- sub('poh', 'meshs', poh_name)
## meteoSchweiz schickt die POH als tif-files, die MESHS aber als tiff-Files
meshs_name <- sub('tif', 'tiff', meshs_name)

## load the HasaR model:
load(paste0(pth_rdata, 'mLogit.rda'))
load(paste0(pth_rdata, 'mGamma.rda'))
load(paste0(pth_rdata, 'mPois.rda'))

## load gegitterte GemDat Daten
load(paste0(pth_rdata, 'GemdatGitter.Rdata'))

## GeoTiff lesen, kommen in folgendem Koordinatensystem
## +proj=somerc +lat_0=46.9524055555556 +lon_0=7.43958333333333 +k_0=1 +x_0=600000 
## +y_0=200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs
poh <- readGDAL(paste0(pth_tif, poh_name))
meshs <- readGDAL(paste0(pth_tif,meshs_name))

## definieren Vektoren fuer x- und y-Koordinaten
## geht auch mit bbox(poh) und gridparameters(poh)
poh_sum <- summary(poh)
x.cellsize <- poh_sum$grid$cellsize[1]
y.cellsize <- poh_sum$grid$cellsize[2]

## Datum aus dem Radarfile extrahieren (fuer Grafik)
per_string <- unlist(strsplit(poh_name, '\\poh.'))[2]
per_string <- unlist(strsplit(per_string, '\\.'))[1]
datum <- as.Date(per_string, format='%Y%m%d')

## Konvertiere die Daten aus dem GeoTiff in einen 2-dimensionalen Array
## --> POH und Meshs-Werte
poh_array <- mirror.matrix(as.array(poh))
meshs_array <- mirror.matrix(as.array(meshs))

if (length(ind.x) > 0 & length(ind.y) > 0) {
  poh_array <- poh_array[ind.x, ind.y]
  meshs_array <- meshs_array[ind.x, ind.y]
}
```

Alle gegitterten Daten in einen Dataframe stecken
```{r eval = FALSE, warning = FALSE}
## In Gitterzellen wo keine Gebaeude stehen (Anzahl = 0) fehlt
## der GVZ die Information zu m?glichen Hagelschaeden.
ind_geb <- which(!is.na(Anzahl)) ## Nur Gitterzellen mit Geb
dat <- data.frame(event = rep(datum, length(ind_geb)),
                  Anzahl = as.numeric(Anzahl[ind_geb]),
                  VersSumme = VersSumme[ind_geb],
                  poh = as.numeric(poh_array[ind_geb]/10), ## poh zw. 0 und 1
                  fact_poh = as.factor(poh_array[ind_geb]/10),
                  meshsclass = as.numeric(meshs_array[ind_geb]),
                  fact_meshsclass = as.factor(meshs_array[ind_geb]),
                  geox = as.numeric(x.coord[ind_geb]),
                  geoy = as.numeric(y.coord[ind_geb]),
                  stringsAsFactors = FALSE)

## von meshsclass abstufung zu meteoschweiz hagelkorngroesse (meshs)
tbl_meshs <- data.frame(meshsclass = seq(from=0, to=10, by=1),
                        meshs = seq(from=1.5, to=6.5, by=0.5))
dat$meshs <- tbl_meshs$meshs[match(dat$meshsclass, tbl_meshs$meshsclass)]

## hagelkorngroessen kleiner als 2 gibt es nicht in meshs
dat <- dat %>% mutate(meshs = ifelse(meshs < 2, 0, meshs),
                      fact_meshs = as.factor(meshs)) %>% 
  # dplyr::select(-c(geox, geoy)) %>%
  filter(poh >= 0.8) ## nur gitterzellen mit mindestens poh 80%
```

#### Schätzung der Schadensumme anhand des Radarbildes der MeteoSchweiz
Die Modellierung erfolgt in zwei Schritten, respektive durch bedingte Wahrscheinlichkeit:
Eine **logistische Regression** schätzt im ersten Teil die Wahrscheinlichkeit fuer einen Schadenseintritt.  

Tritt ein Schaden ein, so wird im zweiten Teil die erwartete Schadenssumme pro Gitterzellen mit einem **GLM mit Gamma Verteilung** (likelihood (link=log)) geschätzt
```{r warning = FALSE}
## fitted(model.glm): predicted values on the original scale
##                    (scale of response, eg the predicted probabilities)
## predict(model.glm, type='response'): same as 'fitted(schadsum.glm)'
##                                      (eg the predicted probabilities)
## predict(model.glm, type='link'): predicted values on the transformed
##                                  scale (scale of linear predictor)

# ## Scatterplot Matrices per event (requires packages'car')
# library(car)
# scatterplotMatrix(dat[,-1], diagonal="density",
#                   pch=19, cex=0.5, spread=F, col.axis='gray50')

## Generate the predicted probabilities with standard errors.
newdat_logit <- cbind(dat, predict(m_logit, newdata = dat, type="link",
                                   se=TRUE))
## Estimates on the link scale and back transform both the predicted
## values and confidence limits into probabilities.
newdat_logit <- within(newdat_logit, {
  estim_prob <- plogis(fit)
  ll_prob <- plogis(fit - (1.96 * se.fit))
  ul_prob <- plogis(fit + (1.96 * se.fit))
})

## mit der funktion 'RemoveMissingLevels' werden alle faktor levels
## die in den original daten (dat) nicht vorkommen auf NA gesetzt
## vorkommen auf NA gesetzt
newdat_gamma <- cbind(dat, predict(m_gamma, newdata = RemoveMissingLevels
                                   (fit = m_gamma, test_data = dat),
                                   type = "link", se = TRUE))

## Estimates on the link scale and back transform both the predicted
## values and confidence limits into loss
newdat_gamma <- within(newdat_gamma, {
  estim_gamma <- exp(fit)
  ll_gam <- exp(fit - (1.96 * se.fit))
  ul_gam <- exp(fit + (1.96 * se.fit))
})

## Generate the predicted number of claims with standard errors.
# newdat_pois <- cbind(dat, predict(m_pois, newdata = dat, type="link",
#                                   se=TRUE))
newdat_pois <- cbind(dat, predict(m_pois, newdata = RemoveMissingLevels
                                  (fit = m_pois, test_data = dat),
                                  type = "link", se = TRUE))

newdat_pois  <- within(newdat_pois, {
  estim_claims <- exp(fit)
  ll_claims <- exp(fit - (1.96 * se.fit))
  ul_claims <- exp(fit + (1.96 * se.fit))
})

## Alles in einen dataframe packen
newdat <- bind_cols(newdat_logit, newdat_gamma[c(12:17)], newdat_pois[c(12:17)]) %>%
  # dplyr::select(-c(5,9)) %>% ## faktoren werden nicht mehr gebraucht
  mutate(estimated_loss_ll = ll_prob * ll_gam,
         estimated_loss = estim_prob * estim_gamma,
         estimated_loss_ul = ul_prob * ul_gam,
         estimated_claims_ll = ll_prob * ll_claims,
         estimated_claims = estim_prob * estim_claims,
         estimated_claims_ul = ul_prob * ul_claims) %>% 
  replace(., is.na(.), 0)

## definiere Arrays fuer die geschaetzte Schadensumme pro Gitterzelle
EstimatedGamma <- EstimatedProb <- EstimatedLoss <- estimated_claims <- 
  array(dim = c(length(xs), length(ys)))
## Schleife ueber Gitterzellen
for (i in 1:length(xs)) {
  for (j in 1:length(ys)) {
    ind <- which(dat$geox > (xs[i] - x.cellsize / 2) &
                   dat$geox <= (xs[i] + x.cellsize / 2) &
                   dat$geoy > (ys[j] - y.cellsize / 2) &
                   dat$geoy <= (ys[j] + y.cellsize / 2))
    if (length(ind) > 0) {
      EstimatedProb[i,j] <- sum(newdat$estim_prob[ind])
      EstimatedGamma[i,j] <- sum(newdat$estim_gamma[ind])
      EstimatedLoss[i,j] <- sum(newdat$estimated_loss[ind])
      estimated_claims[i,j] <- sum(newdat$estimated_claims[ind])
    }
  }
}

# ## Nur geschaetzte Schadensumme, ohne Bandbreite
# pred.m.logit <- predict(m.logit, newdata=dat, type="response")
# pred.m_gamma <- predict(m_gamma, newdata=dat, type="response")
# ## Schadenschaetzung, Modell Fit
# fit.schad <- pred.m_gamma * pred.m.logit
# ## Gesamt-Schadenschaetzung:
# (fit.sum <- sum(pred.m_gamma * pred.m.logit))

df_estimates <- data.frame(lower_loss = sum(newdat$estimated_loss_ll),
                       best_estimate_loss = sum(newdat$estimated_loss),
                       upper_loss = sum(newdat$estimated_loss_ul),
                       lower_claims = sum(newdat$estimated_claims_ll),
                       best_estimate_claims = sum(newdat$estimated_claims),
                       upper_claims = sum(newdat$estimated_claims_ul))

# ## Schadenschaetzung ausgeben:
# message(print(paste0('HASAR - Der geschaetzte Schaden betraegt: ',
#                      round(df_estimates$best_estimate_loss/1e6, 1), ' Mio. CHF bei rund ',
#                      format(round(df_estimates$best_estimate_laims), big.mark = "'"),' Anzahl Schaeden.')))
# message(print(paste0('HASAR - Der geschaetzte Schaden liegt zwischen: ',
#                      round(df_estimates$lower_loss/1e6, 1), ' Mio CHF und ',
#                      round(df_estimates$upper_loss/1e6, 1), ' Mio CHF')))
```


#### PDF Karten erstellen
```{r eval = FALSE, warning = FALSE}
## Transform raster as data.frame to be later used with ggplot
source(paste0(pth_func, 'f.gplotData.R'))

## shapes fuer plots einlesen
sh_gemeinde <- readOGR(paste0(pth_shp, 'gemeinden.2016.shp'), layer = 'gemeinden.2016')
sh_fluss <-readOGR(paste0(pth_shp, 'Fluesse_gross.shp'), layer = 'Fluesse_gross')
sh_seen <-readOGR(paste0(pth_shp, 'seendet_250.shp'), layer = 'seendet_250')
sh_Flug <-readOGR(paste0(pth_shp, 'AVZH_Flughafen_Kloten.shp'),
                  layer = 'AVZH_Flughafen_Kloten')
sh_bezirke <- readOGR(paste0(pth_shp, 'Bezirke.shp'), layer = 'Bezirke')
sh_schaetzkreis <- readOGR(paste0(pth_shp, 'gvz_schaetzkreise.shp'),
                           layer = 'gvz_schaetzkreise')
shp_kanton    <- readOGR(paste0(pth_shp, 'Knt_Umriss wgs84.shp'),
                         layer = "Knt_Umriss wgs84")

## fortify the shapefiles (a function of ggplot) to get it into a dataframe
forti_gemeinde <- fortify(sh_gemeinde)
forti_seen <- fortify(sh_seen)
forti_fluss <- fortify(sh_fluss)
forti_flughaf <- fortify(sh_Flug)
forti_schaetzkreis <- fortify(sh_schaetzkreis)

## set ggplot general theme
theme_set(theme_minimal(base_size = 12))
```

##### MESHS-Radarbild
```{r}
## Transform raster as data.frame to be later used with ggplot
#source(paste0(pth_func, 'f.gplotData.R'))

## MESHS: ACHTUNG, es wird MESHS Class dargestellt
##        und nicht die Korngroessen. Der Join und die Darstellung
##        von Korngroessen erfolgt über "tbl_meshs".

## von array zum raster
meshs_array[meshs_array == 0] <- NA

## create a new - not projected - RasterLayer with the
## meshs cellnumbers as values
rast_meshs <- raster(xmn = min(xs) - x.cellsize / 2, xmx = max(xs) + x.cellsize / 2,
                 ymn = min(ys) - x.cellsize / 2, ymx = max(ys) + x.cellsize / 2,
                 resolution = x.cellsize,
                 vals = rotate90.matrix(meshs_array))
## ch-coordsyst
crs(rast_meshs) <- CRS("+init=epsg:21781") # LV03

## MeteoSwiss  MESHS-Colours in Hex Code (ohne transparenz --> alpha fkt in ggplot
# cols_meshs <- c('#0064ff', '#00c832', '#96ff00',
#                 '#c8ff32', '#ffff00', '#ffc800',
#                 '#ffa000', '#ff7d00', '#ff1600')

cols_meshs <- c("2" = '#0064ff',
                "2.5" = '#00c832',
                "3" = '#96ff00',
                "3.5" = '#c8ff32',
                "4" = '#ffff00',
                "4.5" = '#ffc800',
                "5" = '#ffa000',
                "5.5" = '#ff7d00',
                "6" = '#ff1600')

## Transform MESHS rasters as data frame with function "gplot_data"
gplot_meshs <- gplot_data(rast_meshs) %>%
  mutate(value = ifelse(is.na(value), 0, value)) %>% 
  ## join MESHS from meshs_class
  left_join(y = tbl_meshs, by = c("value" = "meshsclass")) %>% 
  ## ohne 0-Hagelkorn Rasterzellen
  filter(value != 0) %>% 
  mutate(meshs = factor(meshs, levels = seq(1.5, 6, by = 0.5)))


ggMeshs <- ggplot() + coord_equal() +
  geom_polygon(data = forti_gemeinde, aes(long, lat, group = group, fill = hole),
               colour = "gray80", fill = NA, size = 0.1) +
  geom_polygon(data = forti_seen, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#c6dbef") +
  geom_path(data = forti_fluss, aes(long, lat, group = group),
            colour = "#c6dbef", size = 0.5) +
  geom_polygon(data = forti_schaetzkreis, aes(long, lat, group = group, fill = hole) ,
               colour = "black", fill = NA, size = 0.1) +
  geom_polygon(data = forti_flughaf, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#ababab") +
  # geom_polygon(data = forti_avzh, aes(long, lat, group = group, fill = hole) ,
  #              colour = NA, fill = "#ababab") +
  geom_tile(data = gplot_meshs, 
            aes(x = x, y = y, fill = meshs)) +
  scale_fill_manual(name = "MESHS [cm]",
                    values = alpha(cols_meshs, 0.6),
                    limits = names(cols_meshs),
                    drop=FALSE) +
  
  labs(title = "Maximale erwartete Hagelkorngrösse am Boden (MESHS)", 
       subtitle = "", 
       caption = "Quelle: MeteoSchweiz, GG25 swisstopo, bearbeitet durch die GVZ") + 
  
  theme(plot.title = element_text(size = 14, colour = "black", vjust = -5, hjust = 0),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        # panel.border = element_rect(fill = NA, colour = "black"),
        panel.border = element_blank(),
        legend.position = c(.96, .05),
        legend.justification = c("right", "bottom"),
        legend.box.just = "right",
        legend.margin = margin(6, 6, 0, 6),
        legend.key.size = unit(5, "mm"),
        legend.text = element_text(size = 10, colour = "black"),
        legend.background = element_rect(fill = "white", colour = NA),
        # aspect.ratio = sqrt(2)/1, # a4
        plot.margin = unit(c(1,1,1,1),"mm")) # ("left", "right", "bottom", "top")

## --- Save the ggplot's
width_plot = 8
height_plot = (sqrt(2)/1) * width_plot

# Save the plot as a PDF with ggsave and Cairo
# R will want to autocomplete cairo_pdf to cairo_pdf() (note the parentheses)
# This will not work with the parentheses; ensure there aren't any

ggsave(ggMeshs, filename = paste0(pth_pres, "ggMeshs.pdf"), device = cairo_pdf,
       width = width_plot, height = height_plot, units = "in")

cat(paste0('Das MESHS-Radarbild wurde in folgendem Ordner gespeichert:  ',
                     paste0(getwd(), pth_pres, 'meshs.pdf')))

ggMeshs
```

##### POH-Radarbild
```{r}
cols_poh <- c("10" = '#0066ff',
              "20" = '#009696',
              "30" = '#00c832',
              "40" = '#99ff00',
              "50" = '#c9ff32',
              "60" = '#ffff00',
              "70" = '#ffc800',
              "80" = '#ff9d00',
              "90" = '#ff7b00',
              "100" = '#e11600')

## von array zum raster
poh_array[poh_array == 0] <- NA

## create a new - not projected - RasterLayer with the
## poh cellnumbers as values
rast_poh<- raster(xmn = min(xs) - x.cellsize / 2, xmx = max(xs) + x.cellsize / 2,
              ymn = min(ys) - x.cellsize / 2, ymx = max(ys) + x.cellsize / 2,
              resolution = x.cellsize,
              vals = rotate90.matrix(poh_array))
## ch-coordsyst
crs(rast_poh) <- CRS("+init=epsg:21781") # LV03

## Transform rasters as data frame with function "gplot_data"
gplot_poh <- gplot_data(rast_poh) %>% 
  mutate(value = ifelse(is.na(value), 0, value)) %>% 
  ## ohne 0-Hagelwahrscheinlichkeit Rasterzellen
  filter(value != 0) %>% 
  mutate(value = value * 10,
         value = factor(value, levels = seq(10, 100, by = 10)))

ggPoh <- ggplot() + coord_equal() +
  geom_polygon(data = forti_gemeinde, aes(long, lat, group = group, fill = hole),
               colour = "gray80", fill = NA, size = 0.1) +
  geom_polygon(data = forti_seen, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#c6dbef") +
  geom_path(data = forti_fluss, aes(long, lat, group = group),
            colour = "#c6dbef", size = 0.5) +
  geom_polygon(data = forti_schaetzkreis, aes(long, lat, group = group, fill = hole) ,
               colour = "black", fill = NA, size = 0.1) +
  geom_polygon(data = forti_flughaf, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#ababab") +
  # geom_polygon(data = forti_avzh, aes(long, lat, group = group, fill = hole) ,
  #              colour = NA, fill = "#ababab") +
  geom_tile(data = gplot_poh, 
            aes(x = x, y = y, fill = value)) +
  scale_fill_manual(name = "POH [%]",
                    values = alpha(cols_poh, 0.6),
                    limits = names(cols_poh),
                    drop=FALSE) +
  
  labs(title = "Hagelwahrscheinlichkeit (POH)", 
       subtitle = "", 
       caption = "Quelle: MeteoSchweiz, GG25 swisstopo, bearbeitet durch die GVZ") + 
  
  theme(plot.title = element_text(size = 14, colour = "black", vjust = -5, hjust = 0),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        # panel.border = element_rect(fill = NA, colour = "black"),
        panel.border = element_blank(),
        legend.position = c(.96, 0.045),
        legend.justification = c("right", "bottom"),
        legend.box.just = "right",
        legend.margin = margin(6, 6, 0, 6),
        legend.key.size = unit(5, "mm"),
        legend.text = element_text(size = 10, colour = "black"),
        legend.background = element_rect(fill = "white", colour = NA),
        # aspect.ratio = sqrt(2)/1, # a4
        plot.margin = unit(c(1,1,1,1),"mm")) # ("left", "right", "bottom", "top")

## --- Save the ggplot's
width_plot = 8
height_plot = (sqrt(2)/1) * width_plot

# Save the plot as a PDF with ggsave and Cairo
# R will want to autocomplete cairo_pdf to cairo_pdf() (note the parentheses)
# This will not work with the parentheses; ensure there aren't any

ggsave(ggPoh, filename = paste0(pth_pres, "poh.pdf"), device = cairo_pdf,
       width = width_plot, height = height_plot, units = "in")

cat(paste0('Das POH-Radarbild wurde in folgendem Ordner gespeichert:  ',
                     paste0(getwd(), pth_pres, 'poh.pdf')))

ggPoh
```

##### Schadensumme pro 1km x 1km Gitter
```{r}
## breaks anhand quantile
ind <- which(!is.na(EstimatedLoss))
# qntls <- c(0, 0.5, 0.75, 0.90, 0.95, 1)
qntls <- c(0, 0.5, 0.75, 0.9, 1)
brks <- as.numeric(quantile(EstimatedLoss[ind], qntls))
brks <- c(floor(brks[1]), round(brks[2:(length(qntls)-1)]),
          ceiling(brks[length(qntls)]))
# ## TEST
# brks = c(0, 0.5*max(EstimatedLoss[ind]),
#          0.75*max(EstimatedLoss[ind]),
#          0.9*max(EstimatedLoss[ind]), max(EstimatedLoss[ind]))

## labels for ggplot
lbs_schad_qntls <- c(paste0(sprintf("%.2f", qntls[1]), " - ",
                            sprintf("%.2f", qntls[2])),
                     paste0(sprintf("%.2f", qntls[2]), " - ", 
                            sprintf("%.2f", qntls[3])),
                     paste0(sprintf("%.2f", qntls[3]), " - ",
                            sprintf("%.2f", qntls[4])),
                     paste0(sprintf("%.2f", qntls[4]), " - ",
                            sprintf("%.2f", qntls[5])))

lbs_schad_abslt <- c(paste0(format(brks[1], big.mark = "'"), " - ",
                            format(brks[2], big.mark = "'")),
                     paste0(format(brks[2], big.mark = "'"), " - ",
                            format(brks[3], big.mark = "'")),
                     paste0(format(brks[3], big.mark = "'"), " - ",
                            format(brks[4], big.mark = "'")),
                     paste0(format(brks[4], big.mark = "'"), " - ",
                            format(brks[5], big.mark = "'")))

lbs_schad_quali <- c("Gering", "Mässig", "Erheblich", "Gross")
  
## use colorbrewer
# cols_loss <- brewer.pal(9, "YlOrBr")
cols_loss <- brewer.pal(9, "YlOrRd")
cols_loss <- cols_loss[c(1, 3, 4, 6)]

## Modellierte, geschätzte Schadensumme pro Gitter darstellen
## create a new - not projected - RasterLayer with the
## EstimatedLoss cellnumbers as values
rast_loss <- raster(xmn=min(xs)-x.cellsize/2, xmx=max(xs)+x.cellsize/2,
                   ymn=min(ys)-x.cellsize/2, ymx=max(ys)+x.cellsize/2,
                   ncols=dim(EstimatedLoss)[1], nrows=dim(EstimatedLoss)[2],
                   resolution = x.cellsize,
                   vals=rotate90.matrix(EstimatedLoss))

## ch-coordsyst
crs(rast_loss) <- CRS("+init=epsg:21781") # LV03

## Transform rasters as data frame with function "gplot_data"
gplot_loss <- gplot_data(rast_loss)

## divide the continous data in intervals and use those intervals as
## discrete values. Label the quantiles - without zero
gplot_loss <- gplot_loss %>%
  mutate(interval = cut(value, breaks = brks,
                        labels = as.character(qntls[-1]))) %>% 
  ## ohne NA Rasterzellen
  filter(!is.na(interval))

ggSchad <- ggplot() + coord_equal() +
  geom_polygon(data = forti_gemeinde, aes(long, lat, group = group, fill = hole),
               colour = "gray80", fill = NA, size = 0.1) +
  geom_polygon(data = forti_seen, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#c6dbef") +
  geom_path(data = forti_fluss, aes(long, lat, group = group),
            colour = "#c6dbef", size = 0.5) +
  geom_polygon(data = forti_schaetzkreis, aes(long, lat, group = group, fill = hole) ,
               colour = "black", fill = NA, size = 0.1) +
  geom_polygon(data = forti_flughaf, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#ababab") +
  # geom_polygon(data = forti_avzh, aes(long, lat, group = group, fill = hole) ,
  #              colour = NA, fill = "#ababab") +
  geom_tile(data = gplot_loss,
            aes(x = x, y = y, fill = interval)) +
  scale_fill_manual(name = "Auswirkung",
                    # name = "Schadenquantile",
                    # labels = lbs_schad_qntls,
                    # labels = lbs_schad_abslt,
                    labels = lbs_schad_quali,
                    values = alpha(cols_loss, 0.6),
                    na.value = NA) +
  labs(title = "Erwartete Hagelauswirkung", 
       subtitle = "",
       caption = c((paste0("Qualitative Beschreibung der Auswirkung\n",
                   "durch folgende Schadenquantile:\n",
                   paste0("Gering: bis 0.5, Mässig: 0.5-0.75\n",
                          "Erheblich: 0.75-0.9, Gross: über 0.9"))),
                   (paste0("Quelle: MeteoSchweiz, GG25 swisstopo, bearbeitet",
                           "durch die GVZ")))) +

  theme(plot.title = element_text(size = 14, colour = "black", vjust = -5, hjust = 0),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        # panel.border = element_rect(fill = NA, colour = "black"),
        plot.caption = element_text(hjust=c(0, 1), size = 8),
        panel.border = element_blank(),
        legend.position = c(.96, 0.045),
        legend.justification = c("right", "bottom"),
        legend.box.just = "right",
        legend.margin = margin(6, 6, 0, 6),
        legend.key.size = unit(5, "mm"),
        legend.text = element_text(size = 10, colour = "black"),
        legend.background = element_rect(fill = "white", colour = NA),
        # aspect.ratio = sqrt(2)/1, # a4
        plot.margin = unit(c(1,1,1,1),"mm")) # ("left", "right", "bottom", "top")

## --- Save the ggplot's
width_plot = 8
height_plot = (sqrt(2)/1) * width_plot

# Save the plot as a PDF with ggsave and Cairo
# R will want to autocomplete cairo_pdf to cairo_pdf() (note the parentheses)
# This will not work with the parentheses; ensure there aren't any

ggsave(ggSchad, filename = paste0(pth_pres, "Auswirkung.pdf"), device = cairo_pdf,
       width = width_plot, height = height_plot, units = "in")

cat(paste0('Die Schadengrid Grafik wurde in folgendem Ordner gespeichert:  ',
                     paste0(getwd(), pth_pres, 'schaden.pdf')))

ggSchad
```

##### Schadensumme pro Gemeinde
```{r}
## Get sum of schaden-Raster per gemeinde
shp_gemeinde_schad <- raster::extract(rast_loss, sh_gemeinde, small=TRUE, fun=sum,
                                na.rm=TRUE, df=FALSE,  nl=1, sp=TRUE)

## breaks fuer die darstellung
ind <- which(shp_gemeinde_schad@data$layer > 0)
brks_gem <- as.numeric(quantile(shp_gemeinde_schad@data$layer[ind], qntls))
brks_gem <- c(floor(brks_gem[1]), round(brks_gem[2:(length(qntls)-1)]),
              ceiling(brks_gem[length(qntls)]))

## ggplot2 will only work with a data frame object

## define an explicit relationship between the data and the polygons
## associated with that data: add to data a new column termed "id"
## composed of the rownames of data
shp_gemeinde_schad@data$id <- rownames(shp_gemeinde_schad@data)

## divide the continous data in intervals and use those intervals as discrete values
shp_gemeinde_schad@data <- shp_gemeinde_schad@data %>%
  mutate(interval = cut(layer, breaks = brks_gem,
                        labels = as.character(qntls[-1]))) # label quantiles

## fortify the shapefile (a function of ggplot2) to get a data frame
## from the spatial object: region holds the name of the variable by
## which to split regions.
## "rgdal", "ggplot2" und "rgeos" muessen installiert sein!

forti_gemeinde_schad <- ggplot2::fortify(shp_gemeinde_schad, region="id")

## the attribute forti_gemeinde_schad$id contains the mapped value.
## The attributes include spatial coordinates (long and lat), group 
## (coordinates having the same group belongs to the same polygon), and id 
## (each id identifies a feature attribute tuple).

## join the "fortified" data with the data from the spatial object
df_gemeinde_schad <- dplyr::left_join(forti_gemeinde_schad,
                                      shp_gemeinde_schad@data, by="id") %>% 
  filter(!is.na(interval)) # ohne NA Rasterzellen


ggSchadGem <- ggplot() + coord_equal() +
  geom_polygon(data = df_gemeinde_schad, aes(long,lat,group=group,fill=interval)) + 
  geom_polygon() +
  geom_polygon(data = forti_gemeinde, aes(long, lat, group = group, fill = hole),
               colour = "gray80", fill = NA, size = 0.1) +
  geom_polygon(data = forti_seen, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#c6dbef") +
  geom_path(data = forti_fluss, aes(long, lat, group = group),
            colour = "#c6dbef", size = 0.5) +
  geom_polygon(data = forti_schaetzkreis, aes(long, lat, group = group, fill = hole) ,
               colour = "black", fill = NA, size = 0.1) +
  geom_polygon(data = forti_flughaf, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#ababab") +
  # geom_polygon(data = forti_avzh, aes(long, lat, group = group, fill = hole) ,
  #              colour = NA, fill = "#ababab") +
  scale_fill_manual(name = "Auswirkung",
                    # labels = lbs_schad_qntls,
                    labels = lbs_schad_quali,
                    values = alpha(cols_loss, 0.6),
                    na.value = NA) +
  
  labs(title = "Betroffene Gemeinden", 
       subtitle = "",
       caption = c((paste0("Qualitative Beschreibung der Auswirkung\n",
                           "durch folgende Schadenquantile:\n",
                           paste0("Gering: bis 0.5, Mässig: 0.5-0.75\n",
                                  "Erheblich: 0.75-0.9, Gross: über 0.9"))),
                   (paste0("Quelle: GG25 swisstopo, bearbeitet",
                           "durch die GVZ")))) +
  
  theme(plot.title = element_text(size = 14, colour = "black", vjust = -5, hjust = 0),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        # panel.border = element_rect(fill = NA, colour = "black"),
        plot.caption = element_text(hjust=c(0, 1), size = 8),
        panel.border = element_blank(),
        legend.position = c(.96, 0.045),
        legend.justification = c("right", "bottom"),
        legend.box.just = "right",
        legend.margin = margin(6, 6, 0, 6),
        legend.key.size = unit(5, "mm"),
        legend.text = element_text(size = 10, colour = "black"),
        legend.background = element_rect(fill = "white", colour = NA),
        # aspect.ratio = sqrt(2)/1, # a4
        plot.margin = unit(c(1,1,1,1),"mm")) # ("left", "right", "bottom", "top")

## --- Save the ggplot
width_plot = 8
height_plot = (sqrt(2)/1) * width_plot

# Save the plot as a PDF with ggsave and Cairo
# R will want to autocomplete cairo_pdf to cairo_pdf() (note the parentheses)
# This will not work with the parentheses; ensure there aren't any

ggsave(ggSchadGem, filename = paste0(pth_pres, "Betroffene_Gemeinden.pdf"),
       device = cairo_pdf, width = width_plot, height = height_plot,
       units = "in")

cat(paste0('Die Grafik "Schaden pro Gemeinde" wurde in folgendem Ordner gespeichert: ',
                     paste0(getwd(), pth_pres, 'schaden_gemeinde.pdf')))

ggSchadGem
```

##### Anzahl geschätzter Schäden pro Gemeinde
```{r}
# ## create a new - not projected - RasterLayer with the
# ## Anzahl Schaeden per cellnumbers as values
# rast_claims <- raster(xmn=min(xs)-x.cellsize/2, xmx=max(xs)+x.cellsize/2,
#                    ymn=min(ys)-x.cellsize/2, ymx=max(ys)+x.cellsize/2,
#                    ncols=dim(EstimatedLoss)[1], nrows=dim(EstimatedLoss)[2],
#                    resolution = x.cellsize,
#                    vals=rotate90.matrix(estimated_claims))
# 
# ## Get sum of schaden-Raster per gemeinde
# shp_gemeinde_anzahl <- raster::extract(rast_claims, sh_gemeinde, small=TRUE, fun=sum,
#                                      na.rm=TRUE, df=FALSE,  nl=1, sp=TRUE)
# 
# ## breaks fuer die darstellung
# ind <- which(shp_gemeinde_anzahl@data$layer > 0)
# brks_gem_anzahl <- as.numeric(quantile(shp_gemeinde_anzahl@data$layer[ind], qntls))
# brks_gem_anzahl <- c(floor(brks_gem_anzahl[1]), round(brks_gem_anzahl[2:(length(qntls)-1)]),
#               ceiling(brks_gem_anzahl[length(qntls)]))
# 
# lbs_anz_abslt <- c(paste0(format(brks_gem_anzahl[1], big.mark = "'"), " - ",
#                                format(brks_gem_anzahl[2], big.mark = "'")),
#                         paste0(format(brks_gem_anzahl[2], big.mark = "'"), " - ",
#                                format(brks_gem_anzahl[3], big.mark = "'")),
#                         paste0(format(brks_gem_anzahl[3], big.mark = "'"), " - ",
#                                format(brks_gem_anzahl[4], big.mark = "'")),
#                         paste0(format(brks_gem_anzahl[4], big.mark = "'"), " - ",
#                                format(brks_gem_anzahl[5], big.mark = "'")),
#                         paste0(format(brks_gem_anzahl[5], big.mark = "'"), " - ",
#                                format(brks_gem_anzahl[6], big.mark = "'")))
# 
# ## ggplot2 will only work with a data frame object
# 
# ## define an explicit relationship between the data and the polygons associated with that data:
# ## add to data a new column termed "id" composed of the rownames of data
# shp_gemeinde_anzahl@data$id <- rownames(shp_gemeinde_anzahl@data)
# 
# ## divide the continous data in intervals and use those intervals as discrete values
# shp_gemeinde_anzahl@data <- shp_gemeinde_anzahl@data %>%
#   mutate(interval = cut(layer, breaks = brks_gem_anzahl,
#                         labels = as.character(qntls[-1]))) # label quantiles, wihtout zero quant.
# 
# ## fortify the shapefile (a function of ggplot) to get a data.frame from the spatial object:
# ## region holds the name of the variable by which to split regions. 
# forti_gemeinde_anzahl <- fortify(shp_gemeinde_anzahl, region="id")
# 
# ## the attribute forti_gemeinde_schad$id contains the mapped value. The attributes include
# ## spatial coordinates (long and lat), group (coordinates having the same group belongs
# ## to the same polygon), and id (each id identifies a feature attribute tuple).
# 
# ## join the "fortified" data with the data from the spatial object
# df_gemeinde_anzahl <- dplyr::left_join(forti_gemeinde_anzahl, shp_gemeinde_anzahl@data, by="id") %>% 
#   filter(!is.na(interval)) # ohne NA Rasterzellen
# 
# ggAnzahlGem <- ggplot() + coord_equal() +
#   geom_polygon(data = df_gemeinde_anzahl, aes(long,lat,group=group,fill=interval)) + 
#   geom_polygon() +
#   geom_polygon(data = forti_gemeinde, aes(long, lat, group = group, fill = hole),
#                colour = "gray80", fill = NA, size = 0.1) +
#   geom_polygon(data = forti_seen, aes(long, lat, group = group, fill = hole) ,
#                colour = NA, fill = "#c6dbef") +
#   geom_path(data = forti_fluss, aes(long, lat, group = group),
#             colour = "#c6dbef", size = 0.5) +
#   geom_polygon(data = forti_schaetzkreis, aes(long, lat, group = group, fill = hole) ,
#                colour = "black", fill = NA, size = 0.1) +
#   geom_polygon(data = forti_flughaf, aes(long, lat, group = group, fill = hole) ,
#                colour = NA, fill = "#ababab") +
#   scale_fill_manual(name = "Anzahl Schaeden",
#                     labels = brks_gem_anzahl[-1],
#                     values = alpha(cols_loss, 0.6),
#                     na.value = NA) +
#   
#   labs(title = "Geschätzte Anzahl Schäden pro Gemeinde", 
#        subtitle = "",
#        caption = "Quelle: MeteoSchweiz, GG25 swisstopo, bearbeitet durch die GVZ") + 
#   
#   theme(plot.title = element_text(size = 14, colour = "black", vjust = -5, hjust = 0),
#         axis.title = element_blank(),
#         axis.text = element_blank(),
#         panel.grid = element_blank(),
#         # panel.border = element_rect(fill = NA, colour = "black"),
#         panel.border = element_blank(),
#         legend.position = c(.96, 0.045),
#         legend.justification = c("right", "bottom"),
#         legend.box.just = "right",
#         legend.margin = margin(6, 6, 0, 6),
#         legend.key.size = unit(5, "mm"),
#         legend.text = element_text(size = 10, colour = "black"),
#         legend.background = element_rect(fill = "white", colour = NA),
#         # aspect.ratio = sqrt(2)/1, # a4
#         plot.margin = unit(c(1,1,1,1),"mm")) # ("left", "right", "bottom", "top")
# 
# ## --- Save the ggplot
# width_plot = 8
# height_plot = (sqrt(2)/1) * width_plot
# 
# # Save the plot as a PDF with ggsave and Cairo
# # R will want to autocomplete cairo_pdf to cairo_pdf() (note the parentheses)
# # This will not work with the parentheses; ensure there aren't any
# 
# ggsave(ggAnzahlGem, filename = paste0(pth_pres, "schadanzahl_Gemeinde.pdf"),
#        device = cairo_pdf, width = width_plot, height = height_plot,
#        units = "in")

# ggAnzahlGem
```

##### Leaflet Karte
```{r warning = FALSE}
## --- MESHS-Radarbild darstellen

# meshs_array[meshs_array == 0] <- NA
# 
# rast_meshs <- raster(xmn=min(xs)-x.cellsize/2, xmx=max(xs)+x.cellsize/2,
#                  ymn=min(ys)-x.cellsize/2, ymx=max(ys)+x.cellsize/2,
#                  resolution = x.cellsize,
#                  vals=rotate90.matrix(meshs_array))
# ## ch-coordsyst
# crs(rast_meshs) <- CRS("+init=epsg:21781") # LV03

## Change the original raster values (meshsclass) to meshs values
rast_meshs_values <- rast_meshs
rast_meshs_values[rast_meshs_values == 1] <- 2
rast_meshs_values[rast_meshs_values == 2] <- 2.5
rast_meshs_values[rast_meshs_values == 3] <- 3
rast_meshs_values[rast_meshs_values == 4] <- 3.5
rast_meshs_values[rast_meshs_values == 5] <- 4
rast_meshs_values[rast_meshs_values == 6] <- 4.5
rast_meshs_values[rast_meshs_values == 7] <- 5
rast_meshs_values[rast_meshs_values == 8] <- 5.5
rast_meshs_values[rast_meshs_values == 9] <- 6

cols_fact <-colorFactor(palette = cols_meshs,
                    #domain = base::as.factor(sort(unique(values(rast_meshs_values)))),
                    domain = base::as.factor(seq(2, 6, by = 0.5)),
                    na.color = "transparent")

mRadar <- leaflet() %>%
  addProviderTiles("Esri.WorldTopoMap") %>% ## change basemap
  setView(lng = 8.54226, lat = 47.37174, zoom = 10) %>%
  addRasterImage(rast_meshs_values,
                 colors = cols_fact, opacity = 0.6, project=F) %>%
  leaflet::addLegend(position = "bottomright", pal = cols_fact,
            values = values(rast_meshs_values),
            title = "Hagelkorngrösse [cm]")

##--- Modellierte, geschaetzte Schadensumme pro Gitter darstellen

## create a new - not projected - RasterLayer with the
## EstimatedLoss cellnumbers as values

# rast_loss <- raster(xmn=min(xs)-x.cellsize/2, xmx=max(xs)+x.cellsize/2,
#                    ymn=min(ys)-x.cellsize/2, ymx=max(ys)+x.cellsize/2,
#                    ncols=dim(EstimatedLoss)[1], nrows=dim(EstimatedLoss)[2],
#                    resolution = x.cellsize,
#                    vals=rotate90.matrix(EstimatedLoss))
# 
# ## ch-coordsyst
# crs(rast_loss) <- CRS("+init=epsg:21781") # LV03

## bins/breaks anhand quantilen
vals <- na.omit(values(rast_loss))
# prbs <- c(0.5,0.75, 0.90, 0.95, 0.975, 1)
prbs <- c(0.5, 0.75, 0.90, 1)
qtls <- quantile(vals, prbs)
bns <- c(0, ceiling(as.numeric(qtls)))

## Legende mit Schadenzahlen als Kategoriegrenzen
cols_qnt <- colorBin(palette = 'YlOrBr',
                     domain = values(rast_loss),
                bins = bns,
                na.color = 'transparent')

# ## Legende mit Quantilen als Kategoriegrenzen
# cols_qnt <- colorQuantile(palette = 'YlOrBr', domain = vals,
#                      n = length(prbs),
#                      probs = c(0, prbs),
#                      na.color = 'transparent')


# mSchad <- leaflet() %>%
#   addProviderTiles("Esri.WorldTopoMap") %>%
#   setView(lng = 8.54226, lat = 47.37174, zoom = 10) %>%
#   addRasterImage(rast_loss, colors = cols_qnt, opacity = 0.8) %>%
#   leaflet::addLegend(position = "bottomright", pal = cols_qnt,
#             values = values(rast_loss),
#             title = "Auswirkung", className = "info legend",
#             labFormat = labelFormat(big.mark = "'"))

mSchad <- leaflet() %>%
  addProviderTiles("Esri.WorldTopoMap") %>%
  setView(lng = 8.54226, lat = 47.37174, zoom = 10) %>%
  addRasterImage(rast_loss, colors = cols_qnt, opacity = 0.8) %>%
  leaflet::addLegend(position = "bottomright", pal = cols_qnt,
                     values = values(rast_loss),
                     title = "Auswirkung", className = "info legend",
                     # Here's the trick to print qualitative Legend only
                     labFormat = function(type, cuts, p) {
                       paste0(lbs_schad_quali)
                     })


## Radar und Loss in einer Leaflet Map
mCombi <- leaflet() %>% 
  # addTiles(group = "Map") %>%
  addProviderTiles("Esri.WorldTopoMap") %>%
  addProviderTiles("Esri.WorldTopoMap", group = "Esri Topo") %>% 
  addProviderTiles("Esri.WorldImagery", group = "Satellite") %>%
  addRasterImage(rast_loss,  colors = cols_qnt, opacity = 0.8,
                 group = "Auswirkung") %>% 
  addRasterImage(rast_meshs_values, colors = cols_fact, opacity = 0.6,
                 project=F, group = "Radar") %>%
  
  leaflet::addLegend(position='bottomright',
                     pal = cols_qnt,
                     values = values(rast_loss),
                     title = "Auswirkung", className = "info legend",
                     # Here's the trick to print qualitative Legend only
                     labFormat = function(type, cuts, p) {
                       paste0(lbs_schad_quali)}) %>%
  leaflet::addLegend(position = "bottomright", pal = cols_fact,
                     values = values(rast_meshs_values),
                     title = "Hagelkorngrösse [cm]") %>%
  
  hideGroup("Schaden") %>% 
  addLayersControl(
    # baseGroups = c("Map", "Esri Topo", "Satellite"),
    baseGroups = c("Esri Topo", "Satellite"),
    overlayGroups = c("Auswirkung", "Radar"),
    options = layersControlOptions(collapsed = F)
  ) 

# ## Save a html leatlet map
# f <- paste0(gsub("/", "\\", pth_pres, fixed = TRUE), "hagelereignis_", per_string, ".html")
# saveWidget(mCombi, file.path(normalizePath(dirname(f)), basename(f)))
# 
# mCombi
```

#### Schadenschaetzung nach der INTERPOL Methode
Die IMPACT Methode rechnet mit empirischen Betroffenheits- und Schadengraden. Jedem Gebaeude wird anhand des Radarbildes eine Hagelwahrscheinlichkeit zugeordnet. Für die Gebäude mit einer POH von mindestens 80% werden über die Impact Funktion einen Schaden gerechnet. Die Impact Funktion setzt sich zusammen aus Betroffenheits- und Schadengrad (PAA und MDD zu MDR).
Die Impact Funktion leitet sich aus Analysen vergangener Hagelereignisse ab, welche bei der Entwicklung von Haimo sowie im scClim Projekt durchgeführt wurden.

*Hail Impact Function GVZ:*

Meshsclass | MESHS [cm] | Impact     |
---------- | ---------- | ---------- |
0          | 1.5        | 0.00000031 |
1          | 2          | 0.0000033  |
2          | 2.5        | 0.0000092  |
3          | 3          | 0.000018   |
4          | 3.5        | 0.000030   |
5          | 4          | 0.000044   |
6          | 4.5        | 0.000061   |
7          | 5          | 0.000082   |
8          | 5.5        | 0.00011    |
9          | 6          | 0.00013    |
10         | 6.5        | 0.00016    |


```{r warning = FALSE}

## Hail Impact Function
tbl_impfct <- data.frame(meshs = seq(from=1.5, to=6.5, by=0.5),
                         impact = c(3.1e-07,
                                    3.3e-06,
                                    9.2e-06,
                                    1.8e-05,
                                    3e-05,
                                    4.4e-05,
                                    6.1e-05,
                                    8.2e-05,
                                    0.00011,
                                    0.00013,
                                    0.00016))

## definieren das Objekt mit den Radar-Daten fuer interp.surface
loc_obj <- cbind(gemdat$geox, gemdat$geoy)
grid_obj_poh <- list(x = xs,
                   y = ys,
                   z = poh_array)
grid_obj_meshs <- list(x = xs,
                     y = ys,
                     z = meshs_array)

df_interpol <- gemdat %>% dplyr::select(strGebNr, gebNr, gemeinde, versSum,
                                        zweckcode, gebBaujahr, volumen, geox, geoy) %>% 
  ## interpolation der poh und meshs werte auf die gebaeude
  mutate(poh = round(interp.surface(grid_obj_poh, loc_obj),1) *10,
         meshs = round(interp.surface(grid_obj_meshs, loc_obj),1)) %>%
  ## nur Gebäude mit mindestens poh 80%
  filter(poh >= 80)

## left_join(tbl_impfct, by = c('meshs' = 'meshs'))

tbl_out <- data.frame("BaujahrKat" = c("Baujahr bis 1960",
                                      "Baujahr zwischen 1960 und 2002",
                                      "Baujahr ab 2002"),
                     "AnzahlSchad_ohne_0er" = as.integer(t(tbl[1:3])),
                     "Schadensumme" = as.integer(t(tbl[4:6])))
```

## Resultate zusammenfassen und in einem CSV ausgeben
```{r}
df_out <- tribble(
  ~Model, ~Schadensumme, ~Schadenanzahl,
  "HASAR_LOWCONF", df_estimates$lower_loss, round(df_estimates$lower_claims),
  "HASAR_ESTIM", df_estimates$best_estimate_loss, round(df_estimates$best_estimate_claims),
  "HASAR_UPCONF", df_estimates$upper_loss, round(df_estimates$upper_claims),
  "INTERPOL", tbl$schad_hagel, tbl$anzahl_hagel)

# write a estimated loss csv file
name_str <- paste0(pth_pres, "Schadenschätzung_Hagelereignis_", as.Date(eventDat, "%d.%m.%Y"), ".csv")
write_excel_csv(df_out, name_str, delim = ";")

# Message
cat("---\n")
cat(paste0('File saved to ', name_str,'\n---', '\n'))
```

Schadenschätzungen ausgeben
```{r}
cat("---\n")
cat("Schadenschätzung nach HasaR:\n")
cat(paste0('- Schadenschätzung für das Hagelereignis vom ', eventDat, ': CHF ',
           round(df_estimates$best_estimate_loss/1e6, 1), ' Mio. bei rund ',
           format(round(df_estimates$best_estimate_claims), big.mark = "'"),
           ' vergüteten Schäden.'))
cat("\n")
cat(paste0('- Mit einer Wahrscheinlichkeit von 95% liegt der Schaden zwischen: CHF ',
           round(df_estimates$lower_loss/1e6, 1), ' Mio. und ',
           round(df_estimates$upper_loss/1e6, 1), ' Mio.'))
cat("\n")
cat("\n---\n")
cat("Schadenschätzung nach INTERPOL:\n")
cat(paste0('- Schadenschätzung für das Hagelereignis vom ',
           eventDat, ': CHF ',
           format(tbl$schad_hagel/1e6, big.mark="'"), ' Mio. bei rund ',
           format(round(sum(tbl_out$AnzahlSchad_ohne_0er)), big.mark = "'"),
           ' vergüteten Schäden.'))
cat("\n---")
```

               