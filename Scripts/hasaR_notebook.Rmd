---
title: "Hasar - Hagelschadenschaetzung anhand Radardaten"
author: "Mirco Heidemann"
date: "Februar 2018"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

Statistische Modellierung von Hagelschaeden anhand Radardate fuer Ereignisse mit ueber 1'000 Schadenmeldungen.

* Gegitterte GemDat Daten laden
    + Anzahl Gebaeude und Versicherungssumme pro 1km^2 Gitter des Meteoschweiz Radars
    + Fuer eine Aktuallisierung des GVZ Portfolios, erst das R-Skript "Aggregate.GemDat.MeteoSwiss.Grid.R" ausfuehren
* Schaetzung der Schadensumme mit dem statistischen Modell
    + Eine **logistische Regression** schaetzt die Wahrscheinlichkeit fuer einen Schadenseintritt, die erwartete Schadenssumme pro Gitterzellen wird mit einem **GLM mit Gamma Verteilung** modelliert
    + Es werden nur Gitterzellen mit mindestens einem Gebaeude und einer POH von mindestens 80% betrachtet
* PDF - Karten erstellen
    + MESHS (Maximale Korngroesse am Boden) der MeteoSchweiz
    + POH (Hagelwahrscheinlichkeit) der MeteoSchweiz
    + Geschaetzte Schadensumme pro Gitter und Gemeinde
    + Geschaetzte Anzahl Schaeden pro Gemeinde
    + Leaflet - Karte mit MESHS und Schadensumme pro Gitter
* Schaetzung der Schadensumme nach der INTERPOL Methode
    + Empirischen Betroffenheitsgraden je Baujahrskategorie und einem Durchschnittsschaden von CHF 5'000.  

Version: HasaR 3.0

```{r}
## HIER DAS DATUM DES RADARBILDS ANGEBEN
eventDat <- '01.08.2017'
```

Funktionen laden
```{r eval = FALSE, warning = FALSE}
# setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

# pth_data <- ("./data/")
# pth_tbl <- ("./data/tables/")
# pth_func <- ("./data/rfunctions/")
# pth_pres <- ("./presentation/")
# pth_tif <- ("./data/radarTiffs/")
# pth_rdata <- ("./data/rdata/")
# pth_shp <- ("./data/shapes/")

pth_data <- ("C:/Users/mheidemann/Documents/Data_Science/HasaR/data/")
pth_tbl <- ("C:/Users/mheidemann/Documents/Data_Science/HasaR/data/tables/")
pth_func <- ("C:/Users/mheidemann/Documents/Data_Science/HasaR/data/rfunctions/")
pth_pres <- ("C:/Users/mheidemann/Documents/Data_Science/HasaR/presentation/")
pth_tif <- ("C:/Users/mheidemann/Documents/Data_Science/HasaR/data/radarTiffs/")
pth_rdata <- ("C:/Users/mheidemann/Documents/Data_Science/HasaR/data/rdata/")
pth_shp <- ("C:/Users/mheidemann/Documents/Data_Science/HasaR/data/shapes/")

## Funktionen und Packages laden
library(dplyr)
library(rgdal)

## Skript zum Rotieren bzw. Spiegeln vom Radar-Bild laden
source(paste0(pth_func, 'Rotate.R'))
## Funktion um neue Faktor-Levels predict-Datensatz auf NA zu setzen
source(paste0(pth_func, 'RemoveMissingLevels.R'))
```

Daten laden und aufbereiten
```{r eval = FALSE, warning = FALSE}
dat <- as.Date(eventDat, "%d.%m.%Y", tz = "Europe/Berlin")
poh_name <- paste0('poh.', format(dat, "%Y%m%d"),'.tif')
meshs_name <- sub('poh', 'meshs', poh_name)
## meteoSchweiz schickt die POH als tif-files, die MESHS aber als tiff-Files
meshs_name <- sub('tif', 'tiff', meshs_name)

## load the HasaR model:
load(paste0(pth_rdata, 'mLogit.rda'))
load(paste0(pth_rdata, 'mGamma.rda'))
load(paste0(pth_rdata, 'mPois.rda'))

## load gegitterte GemDat Daten
load(paste0(pth_rdata, 'GemdatGitter.Rdata'))

## GeoTiff lesen, kommen in folgendem Koordinatensystem
## +proj=somerc +lat_0=46.9524055555556 +lon_0=7.43958333333333 +k_0=1 +x_0=600000 
## +y_0=200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs
poh <- readGDAL(paste0(pth_tif, poh_name))
meshs <- readGDAL(paste0(pth_tif,meshs_name))

## definieren Vektoren fuer x- und y-Koordinaten
## geht auch mit bbox(poh) und gridparameters(poh)
poh_sum <- summary(poh)
x.cellsize <- poh_sum$grid$cellsize[1]
y.cellsize <- poh_sum$grid$cellsize[2]

## Datum aus dem Radarfile extrahieren (fuer Grafik)
per_string <- unlist(strsplit(poh_name, '\\poh.'))[2]
per_string <- unlist(strsplit(per_string, '\\.'))[1]
datum <- as.Date(per_string, format='%Y%m%d')

## Konvertiere die Daten aus dem GeoTiff in einen 2-dimensionalen Array
## --> POH und Meshs-Werte
poh_array <- mirror.matrix(as.array(poh))
meshs_array <- mirror.matrix(as.array(meshs))

if (length(ind.x) > 0 & length(ind.y) > 0) {
  poh_array <- poh_array[ind.x, ind.y]
  meshs_array <- meshs_array[ind.x, ind.y]
}

## ----
## Alle gegitterten Daten in einen Dataframe stecken

## In Gitterzellen wo keine Gebaeude stehen (Anzahl = 0) fehlt
## der GVZ die Information zu m?glichen Hagelschaeden.
ind_geb <- which(!is.na(Anzahl)) ## Nur Gitterzellen mit Geb
dat <- data.frame(event = rep(datum, length(ind_geb)),
                  Anzahl = as.numeric(Anzahl[ind_geb]),
                  VersSumme = VersSumme[ind_geb],
                  poh = as.numeric(poh_array[ind_geb]/10), ## poh zw. 0 und 1
                  fact_poh = as.factor(poh_array[ind_geb]/10),
                  meshsclass = as.numeric(meshs_array[ind_geb]),
                  fact_meshsclass = as.factor(meshs_array[ind_geb]),
                  geox = as.numeric(x.coord[ind_geb]),
                  geoy = as.numeric(y.coord[ind_geb]),
                  stringsAsFactors = FALSE)

## von meshsclass abstufung zu meteoschweiz hagelkorngroesse (meshs)
tbl_meshs <- data.frame(meshsclass = seq(from=0, to=10, by=1),
                        meshs = seq(from=1.5, to=6.5, by=0.5))
dat$meshs <- tbl_meshs$meshs[match(dat$meshsclass, tbl_meshs$meshsclass)]

## hagelkorngroessen kleiner als 2 gibt es nicht in meshs
dat <- dat %>% mutate(meshs = ifelse(meshs < 2, 0, meshs),
                      fact_meshs = as.factor(meshs)) %>% 
  # dplyr::select(-c(geox, geoy)) %>%
  filter(poh >= 0.8) ## nur gitterzellen mit mindestens poh 80%
```

#### Schaetzung der Schadensumme anhand des Radarbildes der MeteoSchweiz
Die Modellierung erfolgt in zwei Schritten - bedingte Wahrscheinlichkeit:
Eine **logistische Regression** schaetzt im ersten Teil die Wahrscheinlichkeit fuer einen Schadenseintritt.  

Tritt ein Schaden ein, so wird im zweiten Teil die erwartete Schadenssumme pro Gitterzellen mit einem **GLM mit Gamma Verteilung** (likelihood (link=log)) geschaetzt
```{r warning = FALSE}
## fitted(model.glm): predicted values on the original scale
##                    (scale of response, eg the predicted probabilities)
## predict(model.glm, type='response'): same as 'fitted(schadsum.glm)'
##                                      (eg the predicted probabilities)
## predict(model.glm, type='link'): predicted values on the transformed
##                                  scale (scale of linear predictor)

# ## Scatterplot Matrices per event (requires packages'car')
# library(car)
# scatterplotMatrix(dat[,-1], diagonal="density",
#                   pch=19, cex=0.5, spread=F, col.axis='gray50')

## Generate the predicted probabilities with standard errors.
newdat_logit <- cbind(dat, predict(m_logit, newdata = dat, type="link",
                                   se=TRUE))
## Estimates on the link scale and back transform both the predicted
## values and confidence limits into probabilities.
newdat_logit <- within(newdat_logit, {
  estim_prob <- plogis(fit)
  ll_prob <- plogis(fit - (1.96 * se.fit))
  ul_prob <- plogis(fit + (1.96 * se.fit))
})

## mit der funktion 'RemoveMissingLevels' werden alle faktor levels
## die in den original daten (dat) nicht vorkommen auf NA gesetzt
## vorkommen auf NA gesetzt
newdat_gamma <- cbind(dat, predict(m_gamma, newdata = RemoveMissingLevels
                                   (fit = m_gamma, test_data = dat),
                                   type = "link", se = TRUE))

## Estimates on the link scale and back transform both the predicted
## values and confidence limits into loss
newdat_gamma <- within(newdat_gamma, {
  estim_gamma <- exp(fit)
  ll_gam <- exp(fit - (1.96 * se.fit))
  ul_gam <- exp(fit + (1.96 * se.fit))
})

## Generate the predicted number of claims with standard errors.
# newdat_pois <- cbind(dat, predict(m_pois, newdata = dat, type="link",
#                                   se=TRUE))
newdat_pois <- cbind(dat, predict(m_pois, newdata = RemoveMissingLevels
                                  (fit = m_pois, test_data = dat),
                                  type = "link", se = TRUE))

newdat_pois  <- within(newdat_pois, {
  estim_claims <- exp(fit)
  ll_claims <- exp(fit - (1.96 * se.fit))
  ul_claims <- exp(fit + (1.96 * se.fit))
})

## Alles in einen dataframe packen
newdat <- bind_cols(newdat_logit, newdat_gamma[c(12:17)], newdat_pois[c(12:17)]) %>%
  # dplyr::select(-c(5,9)) %>% ## faktoren werden nicht mehr gebraucht
  mutate(estimated_loss_ll = ll_prob * ll_gam,
         estimated_loss = estim_prob * estim_gamma,
         estimated_loss_ul = ul_prob * ul_gam,
         estimated_claims_ll = ll_prob * ll_claims,
         estimated_claims = estim_prob * estim_claims,
         estimated_claims_ul = ul_prob * ul_claims) %>% 
  replace(., is.na(.), 0)

## definiere Arrays fuer die geschaetzte Schadensumme pro Gitterzelle
EstimatedGamma <- EstimatedProb <- EstimatedLoss <- estimated_claims <- 
  array(dim = c(length(xs), length(ys)))
## Schleife ueber Gitterzellen
for (i in 1:length(xs)) {
  for (j in 1:length(ys)) {
    ind <- which(dat$geox > (xs[i] - x.cellsize / 2) &
                   dat$geox <= (xs[i] + x.cellsize / 2) &
                   dat$geoy > (ys[j] - y.cellsize / 2) &
                   dat$geoy <= (ys[j] + y.cellsize / 2))
    if (length(ind) > 0) {
      EstimatedProb[i,j] <- sum(newdat$estim_prob[ind])
      EstimatedGamma[i,j] <- sum(newdat$estim_gamma[ind])
      EstimatedLoss[i,j] <- sum(newdat$estimated_loss[ind])
      estimated_claims[i,j] <- sum(newdat$estimated_claims[ind])
    }
  }
}

# ## Nur geschaetzte Schadensumme, ohne Bandbreite
# pred.m.logit <- predict(m.logit, newdata=dat, type="response")
# pred.m_gamma <- predict(m_gamma, newdata=dat, type="response")
# ## Schadenschaetzung, Modell Fit
# fit.schad <- pred.m_gamma * pred.m.logit
# ## Gesamt-Schadenschaetzung:
# (fit.sum <- sum(pred.m_gamma * pred.m.logit))

df_estimates <- data.frame(lower_loss = sum(newdat$estimated_loss_ll),
                       best_estimate_loss = sum(newdat$estimated_loss),
                       upper_loss = sum(newdat$estimated_loss_ul),
                       lower_claims = sum(newdat$estimated_claims_ll),
                       best_estimate_laims = sum(newdat$estimated_claims),
                       upper_claims = sum(newdat$estimated_claims_ul))

## Schadenschaetzung ausgeben:
message(print(paste0('HASAR - Der geschaetzte Schaden betraegt: ',
                     round(df_estimates$best_estimate_loss/1e6, 1), ' Mio. CHF bei rund ',
                     format(round(df_estimates$best_estimate_laims), big.mark = "'"),' Anzahl Schaeden.')))
message(print(paste0('HASAR - Der geschaetzte Schaden liegt zwischen: ',
                     round(df_estimates$lower_loss/1e6, 1), ' Mio CHF und ',
                     round(df_estimates$upper_loss/1e6, 1), ' Mio CHF')))
```


#### PDF Karten erstellen
```{r eval = FALSE, warning = FALSE}
library(ggplot2)
library(raster)

## shapes fuer plots einlesen
sh_gemeinde <- readOGR(paste0(pth_shp, 'gemeinden.2016.shp'), layer = 'gemeinden.2016')
sh_fluss <-readOGR(paste0(pth_shp, 'Fluesse_gross.shp'), layer = 'Fluesse_gross')
sh_seen <-readOGR(paste0(pth_shp, 'seendet_250.shp'), layer = 'seendet_250')
sh_Flug <-readOGR(paste0(pth_shp, 'AVZH_Flughafen_Kloten.shp'),
                  layer = 'AVZH_Flughafen_Kloten')
sh_bezirke <- readOGR(paste0(pth_shp, 'Bezirke.shp'), layer = 'Bezirke')
sh_schaetzkreis <- readOGR(paste0(pth_shp, 'gvz_schaetzkreise.shp'),
                           layer = 'gvz_schaetzkreise')
shp_kanton    <- readOGR(paste0(pth_shp, 'Knt_Umriss wgs84.shp'),
                         layer = "Knt_Umriss wgs84")

## fortify the shapefiles (a function of ggplot) to get it into a dataframe
forti_gemeinde <- fortify(sh_gemeinde)
forti_seen <- fortify(sh_seen)
forti_fluss <- fortify(sh_fluss)
forti_flughaf <- fortify(sh_Flug)
forti_schaetzkreis <- fortify(sh_schaetzkreis)

## set ggplot general theme
theme_set(theme_minimal(base_size = 12))
```

##### MESHS-Radarbild
```{r}
library(ggplot2)
library(raster)
## Transform raster as data.frame to be later used with ggplot
source(paste0(pth_func, 'f.gplotData.R'))

## MESHS: ACHTUNG, es wird MESHS Class dargestellt
##        und nicht die Korngroessen (see tbl_meshs)

## von array zum raster
meshs_array[meshs_array == 0] <- NA

## create a new - not projected - RasterLayer with the
## meshs cellnumbers as values
rast_meshs <- raster(xmn = min(xs) - x.cellsize / 2, xmx = max(xs) + x.cellsize / 2,
                 ymn = min(ys) - x.cellsize / 2, ymx = max(ys) + x.cellsize / 2,
                 resolution = x.cellsize,
                 vals = rotate90.matrix(meshs_array))
## ch-coordsyst
crs(rast_meshs) <- CRS("+init=epsg:21781") # LV03

## MeteoSwiss  MESHS-Colours in Hex Code (ohne transparenz --> alpha fkt in ggplot
cols_meshs <- c('#0064ff', '#00c832', '#96ff00',
                '#c8ff32', '#ffff00', '#ffc800',
                '#ffa000', '#ff7d00', '#ff1600')

## Transform MESHS rasters as data frame with function "gplot_data"
gplot_meshs <- gplot_data(rast_meshs) %>% 
  mutate(value = ifelse(is.na(value), 0, value),
         value = as.factor(value))

# gplot_meshs <- gplot_meshs %>% 
#   mutate(value = ifelse(is.na(gplot_meshs$value), 0, gplot_meshs$value))

## ohne 0-Hagelkorn Rasterzellen
gplot_meshs <- filter(gplot_meshs, value != 0)

ggMeshs <- ggplot() + coord_equal() +
  geom_polygon(data = forti_gemeinde, aes(long, lat, group = group, fill = hole),
               colour = "gray80", fill = NA, size = 0.1) +
  geom_polygon(data = forti_seen, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#c6dbef") +
  geom_path(data = forti_fluss, aes(long, lat, group = group),
            colour = "#c6dbef", size = 0.5) +
  geom_polygon(data = forti_schaetzkreis, aes(long, lat, group = group, fill = hole) ,
               colour = "black", fill = NA, size = 0.1) +
  geom_polygon(data = forti_flughaf, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#ababab") +
  geom_tile(data = gplot_meshs, 
            aes(x = x, y = y, fill = as.factor(value))) +
  scale_fill_manual(name = "MESHS",
                    values = alpha(cols_meshs, 0.6),
                    labels = c("2", "2.5", "3", "3.5", "4", "4.5", "5", "5.5", "6")) +
  
  labs(title = "Maximale Korngroesse am Boden in cm (MESHS)", 
       subtitle = "", 
       caption = "Quelle: MeteoSchweiz, GG25 swisstopo, bearbeitet durch die GVZ") + 
  
  theme(plot.title = element_text(size = 14, colour = "black", vjust = -5, hjust = 0),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        # panel.border = element_rect(fill = NA, colour = "black"),
        panel.border = element_blank(),
        legend.position = c(.96, .05),
        legend.justification = c("right", "bottom"),
        legend.box.just = "right",
        legend.margin = margin(6, 6, 0, 6),
        legend.key.size = unit(5, "mm"),
        legend.text = element_text(size = 10, colour = "black"),
        legend.background = element_rect(fill = "white", colour = NA),
        # aspect.ratio = sqrt(2)/1, # a4
        plot.margin = unit(c(1,1,1,1),"mm")) # ("left", "right", "bottom", "top")

# ## --- Save the ggplot's
# width_plot = 8
# height_plot = (sqrt(2)/1) * width_plot
# 
# # Save the plot as a PDF with ggsave and Cairo
# # R will want to autocomplete cairo_pdf to cairo_pdf() (note the parentheses)
# # This will not work with the parentheses; ensure there aren't any
# 
# ggsave(ggMeshs, filename = paste0(pth_pres, "meshs.pdf"), device = cairo_pdf,
#        width = width_plot, height = height_plot, units = "in")
# 
# message(print(paste0('Das MESHS-Radarbild wurde in folgendem Ordner gespeichert:  ',
#                      paste0(getwd(), pth_pres, 'meshs.pdf'))))

ggMeshs
```

##### POH-Radarbild
```{r}
## MeteoSwiss POH-Colours in Hex Code (ohne transparenz --> alpha fkt in ggplot)
cols_poh <- c('#0066ff', '#009696', '#00c832', '#99ff00',
              '#c9ff32', '#ffff00', '#ffc800', '#ff9d00',
              '#ff7b00', '#e11600')

## von array zum raster
poh_array[poh_array == 0] <- NA

## create a new - not projected - RasterLayer with the
## poh cellnumbers as values
rast_poh<- raster(xmn = min(xs) - x.cellsize / 2, xmx = max(xs) + x.cellsize / 2,
              ymn = min(ys) - x.cellsize / 2, ymx = max(ys) + x.cellsize / 2,
              resolution = x.cellsize,
              vals = rotate90.matrix(poh_array))
## ch-coordsyst
crs(rast_poh) <- CRS("+init=epsg:21781") # LV03

## Transform rasters as data frame with function "gplot_data"
gplot_poh <- gplot_data(rast_poh) %>% 
  mutate(value = ifelse(is.na(value), 0, value),
         value = as.factor(value))

## ohne 0-Hagelw'keit Rasterzellen
gplot_poh <- filter(gplot_poh, value != 0)

ggPoh <- ggplot() + coord_equal() +
  geom_polygon(data = forti_gemeinde, aes(long, lat, group = group, fill = hole),
               colour = "gray80", fill = NA, size = 0.1) +
  geom_polygon(data = forti_seen, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#c6dbef") +
  geom_path(data = forti_fluss, aes(long, lat, group = group),
            colour = "#c6dbef", size = 0.5) +
  geom_polygon(data = forti_schaetzkreis, aes(long, lat, group = group, fill = hole) ,
               colour = "black", fill = NA, size = 0.1) +
  geom_polygon(data = forti_flughaf, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#ababab") +
  geom_tile(data = gplot_poh, 
            aes(x = x, y = y, fill = as.factor(value))) +
  scale_fill_manual(name = "POH",
                    values = alpha(cols_poh, 0.6),
                    labels = c("10 %", "20 %", "30 %", "40 %", "50 %",
                               "60 %", "70 %", "80 %", "90 %", "100 %")) +
  
  labs(title = "Hagelwahrscheinlichkeit (POH)", 
       subtitle = "", 
       caption = "Quelle: MeteoSchweiz, GG25 swisstopo, bearbeitet durch die GVZ") + 
  
  theme(plot.title = element_text(size = 14, colour = "black", vjust = -5, hjust = 0),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        # panel.border = element_rect(fill = NA, colour = "black"),
        panel.border = element_blank(),
        legend.position = c(.96, 0.045),
        legend.justification = c("right", "bottom"),
        legend.box.just = "right",
        legend.margin = margin(6, 6, 0, 6),
        legend.key.size = unit(5, "mm"),
        legend.text = element_text(size = 10, colour = "black"),
        legend.background = element_rect(fill = "white", colour = NA),
        # aspect.ratio = sqrt(2)/1, # a4
        plot.margin = unit(c(1,1,1,1),"mm")) # ("left", "right", "bottom", "top")

# ## --- Save the ggplot's
# width_plot = 8
# height_plot = (sqrt(2)/1) * width_plot
# 
# # Save the plot as a PDF with ggsave and Cairo
# # R will want to autocomplete cairo_pdf to cairo_pdf() (note the parentheses)
# # This will not work with the parentheses; ensure there aren't any
# 
# ggsave(ggPoh, filename = paste0(, pth_pres, "poh.pdf"), device = cairo_pdf,
#        width = width_plot, height = height_plot, units = "in")
# 
# message(print(paste0('Das POH-Radarbild wurde in folgendem Ordner gespeichert:  ',
#                      paste0(getwd(), pth_pres, 'poh.pdf'))))

ggPoh
```

##### Schadensumme pro 1km x 1km Gitter (Radar Aufloesung)
```{r}
library(RColorBrewer)

## breaks anhand quantile
ind <- which(!is.na(EstimatedLoss))
qntls <- c(0, 0.5, 0.75, 0.90, 0.95, 1)
brks <- as.numeric(quantile(EstimatedLoss[ind], qntls))
brks <- c(floor(brks[1]), round(brks[2:(length(qntls)-1)]), ceiling(brks[length(qntls)]))

## labels for ggplot
lbs_schad_qntls <- c(paste0(sprintf("%.2f", qntls[1]), " - ", sprintf("%.2f", qntls[2])),
                     paste0(sprintf("%.2f", qntls[2]), " - ", sprintf("%.2f", qntls[3])),
                     paste0(sprintf("%.2f", qntls[3]), " - ", sprintf("%.2f", qntls[4])),
                     paste0(sprintf("%.2f", qntls[4]), " - ", sprintf("%.2f", qntls[5])),
                     paste0(sprintf("%.2f", qntls[5]), " - ", sprintf("%.2f", qntls[6])))

lbs_schad_abslt <- c(paste0(format(brks[1], big.mark = "'"), " - ", format(brks[2], big.mark = "'")),
                     paste0(format(brks[2], big.mark = "'"), " - ", format(brks[3], big.mark = "'")),
                     paste0(format(brks[3], big.mark = "'"), " - ", format(brks[4], big.mark = "'")),
                     paste0(format(brks[4], big.mark = "'"), " - ", format(brks[5], big.mark = "'")),
                     paste0(format(brks[5], big.mark = "'"), " - ", format(brks[6], big.mark = "'")))

## use colorbrewer
# cols_loss <- brewer.pal(9, "YlOrBr")
cols_loss <- brewer.pal(9, "YlOrRd")
cols_loss <- cols_loss[2:6]

## Modellierte, geschaetzte Schadensumme pro Gitter darstellen
## create a new - not projected - RasterLayer with the
## EstimatedLoss cellnumbers as values
rast_loss <- raster(xmn=min(xs)-x.cellsize/2, xmx=max(xs)+x.cellsize/2,
                   ymn=min(ys)-x.cellsize/2, ymx=max(ys)+x.cellsize/2,
                   ncols=dim(EstimatedLoss)[1], nrows=dim(EstimatedLoss)[2],
                   resolution = x.cellsize,
                   vals=rotate90.matrix(EstimatedLoss))

## ch-coordsyst
crs(rast_loss) <- CRS("+init=epsg:21781") # LV03

## Transform rasters as data frame with function "gplot_data"
gplot_loss <- gplot_data(rast_loss)

## divide the continous data in intervals and use those intervals as discrete values
## label the quantiles - without zero
gplot_loss <- gplot_loss %>%
  mutate(interval = cut(gplot_loss$value, breaks = brks,
                        labels = as.character(qntls[-1])))

## ohne NA Rasterzellen
gplot_loss <- filter(gplot_loss, !is.na(interval))

ggSchad <- ggplot() + coord_equal() +
  geom_polygon(data = forti_gemeinde, aes(long, lat, group = group, fill = hole),
               colour = "gray80", fill = NA, size = 0.1) +
  geom_polygon(data = forti_seen, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#c6dbef") +
  geom_path(data = forti_fluss, aes(long, lat, group = group),
            colour = "#c6dbef", size = 0.5) +
  geom_polygon(data = forti_schaetzkreis, aes(long, lat, group = group, fill = hole) ,
               colour = "black", fill = NA, size = 0.1) +
  geom_polygon(data = forti_flughaf, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#ababab") +
  geom_tile(data = gplot_loss,
            aes(x = x, y = y, fill = interval)) +
  scale_fill_manual(name = "Schadenquantile",
                    labels = lbs_schad_qntls,
                    values = alpha(cols_loss, 0.6),
                    na.value = NA) +
  labs(title = "Geschaetzte Schadensumme", 
       subtitle = "", 
       caption = "Quelle: MeteoSchweiz, GG25 swisstopo, bearbeitet durch die GVZ") + 
  
  theme(plot.title = element_text(size = 14, colour = "black", vjust = -5, hjust = 0),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        # panel.border = element_rect(fill = NA, colour = "black"),
        panel.border = element_blank(),
        legend.position = c(.96, 0.045),
        legend.justification = c("right", "bottom"),
        legend.box.just = "right",
        legend.margin = margin(6, 6, 0, 6),
        legend.key.size = unit(5, "mm"),
        legend.text = element_text(size = 10, colour = "black"),
        legend.background = element_rect(fill = "white", colour = NA),
        # aspect.ratio = sqrt(2)/1, # a4
        plot.margin = unit(c(1,1,1,1),"mm")) # ("left", "right", "bottom", "top")

# ## --- Save the ggplot's
# width_plot = 8
# height_plot = (sqrt(2)/1) * width_plot
# 
# # Save the plot as a PDF with ggsave and Cairo
# # R will want to autocomplete cairo_pdf to cairo_pdf() (note the parentheses)
# # This will not work with the parentheses; ensure there aren't any
# 
# ggsave(ggSchad, filename = paste0(pth_pres, "schaden.pdf"), device = cairo_pdf,
#        width = width_plot, height = height_plot, units = "in")
# 
# message(print(paste0('Die Schadengrid Grafik wurde in folgendem Ordner gespeichert:  ',
#                      paste0(getwd(), pth_pres, 'schaden.pdf'))))

ggSchad
```

##### Schadensumme pro Gemeinde
```{r}
## Get sum of schaden-Raster per gemeinde
shp_gemeinde_schad <- raster::extract(rast_loss, sh_gemeinde, small=TRUE, fun=sum,
                                na.rm=TRUE, df=FALSE,  nl=1, sp=TRUE)

## breaks fuer die darstellung
ind <- which(shp_gemeinde_schad@data$layer > 0)
brks_gem <- as.numeric(quantile(shp_gemeinde_schad@data$layer[ind], qntls))
brks_gem <- c(floor(brks_gem[1]), round(brks_gem[2:(length(qntls)-1)]),
              ceiling(brks_gem[length(qntls)]))

## ggplot2 will only work with a data.frame objec.

## define an explicit relationship between the data and the polygons associated with that data:
## add to data a new column termed "id" composed of the rownames of data
shp_gemeinde_schad@data$id <- rownames(shp_gemeinde_schad@data)

## divide the continous data in intervals and use those intervals as discrete values
shp_gemeinde_schad@data <- shp_gemeinde_schad@data %>%
  mutate(interval = cut(layer, breaks = brks_gem,
                        labels = as.character(qntls[-1]))) # label quantiles

## fortify the shapefile (a function of ggplot) to get a data.frame from the spatial object:
## region holds the name of the variable by which to split regions. 
## "rgdal", "ggplot2" und "rgeos" muessen installiert sein!
forti_gemeinde_schad <- fortify(shp_gemeinde_schad, region="id")

## the attribute forti_gemeinde_schad$id contains the mapped value. The attributes include
## spatial coordinates (long and lat), group (coordinates having the same group belongs
## to the same polygon), and id (each id identifies a feature attribute tuple).

## join the "fortified" data with the data from the spatial object
df_gemeinde_schad <- dplyr::left_join(forti_gemeinde_schad, shp_gemeinde_schad@data, by="id") %>% 
  filter(!is.na(interval)) # ohne NA Rasterzellen


ggSchadGem <- ggplot() + coord_equal() +
  geom_polygon(data = df_gemeinde_schad, aes(long,lat,group=group,fill=interval)) + 
  geom_polygon() +
  geom_polygon(data = forti_gemeinde, aes(long, lat, group = group, fill = hole),
               colour = "gray80", fill = NA, size = 0.1) +
  geom_polygon(data = forti_seen, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#c6dbef") +
  geom_path(data = forti_fluss, aes(long, lat, group = group),
            colour = "#c6dbef", size = 0.5) +
  geom_polygon(data = forti_schaetzkreis, aes(long, lat, group = group, fill = hole) ,
               colour = "black", fill = NA, size = 0.1) +
  geom_polygon(data = forti_flughaf, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#ababab") +
  scale_fill_manual(name = "Schadenquantile",
                    labels = lbs_schad_qntls,
                    values = alpha(cols_loss, 0.6),
                    na.value = NA) +
  
  labs(title = "Geschaetzte Schadensumme pro Gemeinde", 
       subtitle = "", 
       caption = "Quelle: MeteoSchweiz, GG25 swisstopo, bearbeitet durch die GVZ") + 
  
  theme(plot.title = element_text(size = 14, colour = "black", vjust = -5, hjust = 0),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        # panel.border = element_rect(fill = NA, colour = "black"),
        panel.border = element_blank(),
        legend.position = c(.96, 0.045),
        legend.justification = c("right", "bottom"),
        legend.box.just = "right",
        legend.margin = margin(6, 6, 0, 6),
        legend.key.size = unit(5, "mm"),
        legend.text = element_text(size = 10, colour = "black"),
        legend.background = element_rect(fill = "white", colour = NA),
        # aspect.ratio = sqrt(2)/1, # a4
        plot.margin = unit(c(1,1,1,1),"mm")) # ("left", "right", "bottom", "top")

# ## --- Save the ggplot
# width_plot = 8
# height_plot = (sqrt(2)/1) * width_plot
# 
# # Save the plot as a PDF with ggsave and Cairo
# # R will want to autocomplete cairo_pdf to cairo_pdf() (note the parentheses)
# # This will not work with the parentheses; ensure there aren't any
# 
# ggsave(ggSchadGem, filename = paste0(pth_pres, "schaden_gemeinde.pdf"), device = cairo_pdf,
#        width = width_plot, height = height_plot, units = "in")
# 
# message(print(paste0('Die Grafik "Schaden pro Gemeinde" wurde in folgendem Ordner gespeichert: ',
#                      paste0(getwd(), pth_pres, 'schaden_gemeinde.pdf'))))

ggSchadGem
```

##### Anzahl geschaetzter Schaeden pro Gemeinde
```{r}
## create a new - not projected - RasterLayer with the
## Anzahl Schaeden per cellnumbers as values
rast_claims <- raster(xmn=min(xs)-x.cellsize/2, xmx=max(xs)+x.cellsize/2,
                   ymn=min(ys)-x.cellsize/2, ymx=max(ys)+x.cellsize/2,
                   ncols=dim(EstimatedLoss)[1], nrows=dim(EstimatedLoss)[2],
                   resolution = x.cellsize,
                   vals=rotate90.matrix(estimated_claims))

## Get sum of schaden-Raster per gemeinde
shp_gemeinde_anzahl <- raster::extract(rast_claims, sh_gemeinde, small=TRUE, fun=sum,
                                     na.rm=TRUE, df=FALSE,  nl=1, sp=TRUE)

## breaks fuer die darstellung
ind <- which(shp_gemeinde_anzahl@data$layer > 0)
brks_gem_anzahl <- as.numeric(quantile(shp_gemeinde_anzahl@data$layer[ind], qntls))
brks_gem_anzahl <- c(floor(brks_gem_anzahl[1]), round(brks_gem_anzahl[2:(length(qntls)-1)]),
              ceiling(brks_gem_anzahl[length(qntls)]))

lbs_anz_abslt <- c(paste0(format(brks_gem_anzahl[1], big.mark = "'"), " - ",
                               format(brks_gem_anzahl[2], big.mark = "'")),
                        paste0(format(brks_gem_anzahl[2], big.mark = "'"), " - ",
                               format(brks_gem_anzahl[3], big.mark = "'")),
                        paste0(format(brks_gem_anzahl[3], big.mark = "'"), " - ",
                               format(brks_gem_anzahl[4], big.mark = "'")),
                        paste0(format(brks_gem_anzahl[4], big.mark = "'"), " - ",
                               format(brks_gem_anzahl[5], big.mark = "'")),
                        paste0(format(brks_gem_anzahl[5], big.mark = "'"), " - ",
                               format(brks_gem_anzahl[6], big.mark = "'")))

## ggplot2 will only work with a data.frame objec.

## define an explicit relationship between the data and the polygons associated with that data:
## add to data a new column termed "id" composed of the rownames of data
shp_gemeinde_anzahl@data$id <- rownames(shp_gemeinde_anzahl@data)

## divide the continous data in intervals and use those intervals as discrete values
shp_gemeinde_anzahl@data <- shp_gemeinde_anzahl@data %>%
  mutate(interval = cut(layer, breaks = brks_gem_anzahl,
                        labels = as.character(qntls[-1]))) # label quantiles, wihtout zero quant.

## fortify the shapefile (a function of ggplot) to get a data.frame from the spatial object:
## region holds the name of the variable by which to split regions. 
forti_gemeinde_anzahl <- fortify(shp_gemeinde_anzahl, region="id")

## the attribute forti_gemeinde_schad$id contains the mapped value. The attributes include
## spatial coordinates (long and lat), group (coordinates having the same group belongs
## to the same polygon), and id (each id identifies a feature attribute tuple).

## join the "fortified" data with the data from the spatial object
df_gemeinde_anzahl <- dplyr::left_join(forti_gemeinde_anzahl, shp_gemeinde_anzahl@data, by="id") %>% 
  filter(!is.na(interval)) # ohne NA Rasterzellen

ggAnzahlGem <- ggplot() + coord_equal() +
  geom_polygon(data = df_gemeinde_anzahl, aes(long,lat,group=group,fill=interval)) + 
  geom_polygon() +
  geom_polygon(data = forti_gemeinde, aes(long, lat, group = group, fill = hole),
               colour = "gray80", fill = NA, size = 0.1) +
  geom_polygon(data = forti_seen, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#c6dbef") +
  geom_path(data = forti_fluss, aes(long, lat, group = group),
            colour = "#c6dbef", size = 0.5) +
  geom_polygon(data = forti_schaetzkreis, aes(long, lat, group = group, fill = hole) ,
               colour = "black", fill = NA, size = 0.1) +
  geom_polygon(data = forti_flughaf, aes(long, lat, group = group, fill = hole) ,
               colour = NA, fill = "#ababab") +
  scale_fill_manual(name = "Anzahl Schaeden",
                    labels = brks_gem_anzahl[-1],
                    values = alpha(cols_loss, 0.6),
                    na.value = NA) +
  
  labs(title = "Geschaetzte Anzahl Schaeden pro Gemeinde", 
       subtitle = "", 
       caption = "Quelle: MeteoSchweiz, GG25 swisstopo, bearbeitet durch die GVZ") + 
  
  theme(plot.title = element_text(size = 14, colour = "black", vjust = -5, hjust = 0),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        # panel.border = element_rect(fill = NA, colour = "black"),
        panel.border = element_blank(),
        legend.position = c(.96, 0.045),
        legend.justification = c("right", "bottom"),
        legend.box.just = "right",
        legend.margin = margin(6, 6, 0, 6),
        legend.key.size = unit(5, "mm"),
        legend.text = element_text(size = 10, colour = "black"),
        legend.background = element_rect(fill = "white", colour = NA),
        # aspect.ratio = sqrt(2)/1, # a4
        plot.margin = unit(c(1,1,1,1),"mm")) # ("left", "right", "bottom", "top")

# ## --- Save the ggplot
# width_plot = 8
# height_plot = (sqrt(2)/1) * width_plot
# 
# # Save the plot as a PDF with ggsave and Cairo
# # R will want to autocomplete cairo_pdf to cairo_pdf() (note the parentheses)
# # This will not work with the parentheses; ensure there aren't any
# 
# ggsave(ggSchadgem, filename = "schaden_anzahl.pdf", device = cairo_pdf,
#        width = width_plot, height = height_plot, units = "in")
# 
# message(print(paste0('Die Grafik "Anzahl Schaeden pro Gemeinde" wurde in folgendem Ordner gespeichert: ', paste0(getwd(), pth_pres, 'schaden_anzahl.pdf'))))

ggAnzahlGem
```

##### Leaflet Karte
```{r warning = FALSE}
library(leaflet)
  
## --- MESHS-Radarbild darstellen

# meshs_array[meshs_array == 0] <- NA
# 
# rast_meshs <- raster(xmn=min(xs)-x.cellsize/2, xmx=max(xs)+x.cellsize/2,
#                  ymn=min(ys)-x.cellsize/2, ymx=max(ys)+x.cellsize/2,
#                  resolution = x.cellsize,
#                  vals=rotate90.matrix(meshs_array))
# ## ch-coordsyst
# crs(rast_meshs) <- CRS("+init=epsg:21781") # LV03

cols_fact <-colorFactor(palette = cols_meshs,
                    domain = base::as.factor(sort(unique(values(rast_meshs)))),
                    na.color = "transparent")

mRadar <- leaflet() %>%
  addProviderTiles("Esri.WorldTopoMap") %>% ## change basemap
  setView(lng = 8.54226, lat = 47.37174, zoom = 10) %>%
  addRasterImage(rast_meshs, colors = cols_fact, opacity = 0.6, project=F) %>%
  addLegend(position = "bottomright", pal = cols_fact,
            values = values(rast_meshs),
            title = "MESHS",
            labFormat = function(type, cuts, p) {
              n = length(cuts)
              p = c("2", "2.5", "3", "3.5",
                    "4", "4.5", "5", "5.5", "6")})

##--- Modellierte, geschaetzte Schadensumme pro Gitter darstellen

## create a new - not projected - RasterLayer with the
## EstimatedLoss cellnumbers as values

# rast_loss <- raster(xmn=min(xs)-x.cellsize/2, xmx=max(xs)+x.cellsize/2,
#                    ymn=min(ys)-x.cellsize/2, ymx=max(ys)+x.cellsize/2,
#                    ncols=dim(EstimatedLoss)[1], nrows=dim(EstimatedLoss)[2],
#                    resolution = x.cellsize,
#                    vals=rotate90.matrix(EstimatedLoss))
# 
# ## ch-coordsyst
# crs(rast_loss) <- CRS("+init=epsg:21781") # LV03

## bins/breaks anhand quantilen
vals <- na.omit(values(rast_loss))
prbs <- c(0.5,0.75, 0.90, 0.95, 0.975, 1)
qtls <- quantile(vals, prbs)
bns <- c(0, ceiling(as.numeric(qtls)))

# ## Legende mit Schadenzahlen als Kategoriegrenzen
# cols_qnt <- colorBin(palette = 'YlOrBr', domain = values(rast_loss),
#                 bins = bns, na.color = 'transparent')

## Legende mit Quantilen als Kategoriegrenzen
cols_qnt <- colorQuantile(palette = 'YlOrBr', domain = vals,
                     n = length(prbs), probs = c(0, prbs),
                     na.color = 'transparent')

mSchad <- leaflet() %>%
  addProviderTiles("Esri.WorldTopoMap") %>%
  setView(lng = 8.54226, lat = 47.37174, zoom = 10) %>%
  addRasterImage(rast_loss, colors = cols_qnt, opacity = 0.8) %>%
  addLegend(position = "bottomright", pal = cols_qnt,
            values = values(rast_loss),
            title = "Schaden", className = "info legend",
            labFormat = labelFormat(big.mark = "'"))


## Radar und Loss in einer Leaflet Map
mCombi <- leaflet() %>% 
  # addTiles(group = "Map") %>%
  addProviderTiles("Esri.WorldTopoMap") %>%
  addProviderTiles("Esri.WorldTopoMap", group = "Esri Topo") %>% 
  addProviderTiles("Esri.WorldImagery", group = "Satellite") %>%
  addRasterImage(rast_loss,  colors = cols_qnt, opacity = 0.8, group = "Schaden") %>% 
  addRasterImage(rast_meshs, colors = cols_fact, opacity = 0.6, project=F, group = "Radar") %>%
  
  ## Legends are not yet controllable with the raster images
  # addLegend(position='bottomright',
  #           pal = cols_qnt,
  #           values = values(rast_loss),
  #           title = "Schaden", className = "info legend",
  #           labFormat = labelFormat(big.mark = "'")) %>%
  # addLegend(position = "bottomright", pal = cols_fact,
  #           values = values(rast_meshs),
  #           title = "MESHS",
  #           labFormat = function(type, cuts, p) {
  #             n = length(cuts)
  #             p = c("< 2", "2.5", "3", "3.5",
  #                   "4", "4.5", "5", "5.5", "6")}) %>% 
  hideGroup("Schaden") %>% 
  addLayersControl(
    # baseGroups = c("Map", "Esri Topo", "Satellite"),
    baseGroups = c("Esri Topo", "Satellite"),
    overlayGroups = c("Schaden", "Radar"),
    options = layersControlOptions(collapsed = FALSE)
  ) 

mCombi
```

#### Schadenschaetzung nach der INTERPOL Methode
Die INTERPOL Methode rechnet mit empirischen Betroffenheitsgraden je Baujahrskategorie und einem Durchschnittsschaden von CHF 5'000. Die Hagelkorngroesse wird dabei nicht beruecksichtigt. Jedem Gebaeude wird anhand des Radarbildes eine Hagelwahrscheinlichkeit zugeordnet (interpoliert). Die Gebaeude mit einer POH von mindestens 80% werden selektiert und je nach Baujahrskategorie unterschiedliche Betroffenheitsgrade angewandt. Betroffenheitsgrad mal die Anzahl selektierter Gebaeude pro Baujahrskategorie ergibt die Anzahl betroffener Gebaeude pro Baujahrskategorie.  

Betroffenheitsgrade:

* Gebaeude mit Baujahr aelter als 1960: 0.03
* Gebaeude mit Baujahr zwischen 1960 und 2002: 0.06
* Gebaeude mit Baujahr juenger als 2002: 0.08

Quelle fuer die Betroffenheitsgrade und Durchschnittsschaden:
*analyse.hagelevents.xlsx, MHE, Nov 2017*

```{r warning = FALSE}
library(fields) ## interp.surface

## definieren das Objekt mit den Radar-Daten fuer interp.surface
loc_obj <- cbind(gemdat$geox, gemdat$geoy)
grid_obj_poh <- list(x = xs,
                   y = ys,
                   z = poh_array)
grid_obj_meshs <- list(x = xs,
                     y = ys,
                     z = meshs_array)

df_interpol <- gemdat %>% dplyr::select(strGebNr, gebNr, gemeinde, versSum,
                                        zweckcode, gebBaujahr, volumen, geox, geoy) %>% 
  ## interpolation der poh und meshs werte auf die gebaeude
  mutate(poh = round(interp.surface(grid_obj_poh, loc_obj),1) *10,
         meshs = round(interp.surface(grid_obj_meshs, loc_obj),1),
         baujahr_kat = ifelse(gebBaujahr < 1960, 1,
                        ifelse(gebBaujahr <= 2002,2,3))) %>%
  ## nur gitterzellen mit mindestens poh 80%
  filter(poh >= 80)

# ## "turn off" scientific notation in write.csv 
# df_interpol$geox <- format(df_interpol$geox, scientific = FALSE)
# df_interpol$geoy <- format(df_interpol$geoy, scientific = FALSE)
# df_interpol$pohInterpol <- format(df_interpol$pohInterpol, scientific = FALSE)
# df_interpol$meshsInterpol <- format(df_interpol$meshsInterpol, scientific = FALSE)
# write.csv2(df_interpol, 'testInterpol3.csv', row.names = F)

## statistische Kennzahl
## Quelle: analyse.hagelevents.xlsx, Nov 2017, MHE
schad_mean <- 5e3
kat_1 <- 3e-2
kat_2 <- 6e-2
kat_3 <- 8e-2

# schad <- read.csv2('./Rdata/hagelschad.170802.csv', stringsAsFactors = FALSE)
# 
# dat <- dat %>% mutate(schadSum = schad$indexSchad[match(dat$gebNr, schad$gebnr)],
#                       schadSum = ifelse(is.na(schadSum), 0, schadSum),
#                       schadLogi = ifelse(schadSum == 0, 0, 1),
#                       baujahr_kat = ifelse(gebBaujahr < 1960, 1,
#                                      ifelse(gebBaujahr <= 2002,2,3))) %>% 
#   group_by(baujahr_kat)
# ## mean pro gebjahr kat
# summarise(dat, round(mean(schadSum[schadSum>0]),0))
# ## median pro gebjahr kat
# summarise(dat, round(median(schadSum[schadSum>0]),0))
# ## betroffenheit pro gebjahr kat
# summarise(dat, ceiling(sum(schadLogi == 1)/sum(schadLogi == 0) *100))

## auswahl betroffener Gebaeude
tbl <- data.frame(anz_kat_1 = round(sum(df_interpol$baujahr_kat == 1) *kat_1, 0),
                  anz_kat_2 = round(sum(df_interpol$baujahr_kat == 2) *kat_2, 0),
                  anz_kat_3 = round(sum(df_interpol$baujahr_kat == 3) *kat_3, 0)) %>% 
  mutate(schad_kat_1 = anz_kat_1 *schad_mean,
         schad_kat_2 = anz_kat_2 *schad_mean,
         schad_kat_3 = anz_kat_3 *schad_mean,
         schad_hagel = schad_kat_1 + schad_kat_2 + schad_kat_3)

tbl_out <- data.frame("BaujahrKat" = c("Baujahr bis 1960",
                                      "Baujahr zwischen 1960 und 2002",
                                      "Baujahr ab 2002"),
                     "AnzahlSchad" = as.integer(t(tbl[1:3])),
                     "Schadensumme" = as.integer(t(tbl[4:6])))

message(print(paste0('INTERPOL - Schadenschaetzung fuer das Hagelereignis vom ',
                     eventDat, ': CHF ',
                     format(tbl$schad_hagel/1e6, big.mark="'"), ' Mio')))
```
